#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <time.h>
#include <linux/fb.h>

#define FBDEV_DEF "/dev/fb0"
static char *fbdev_fn = NULL;
static int fbdev_fd = -1;
static uint8_t *fbdev_mem = NULL;
static struct fb_fix_screeninfo fbdev_finfo;
static struct fb_var_screeninfo fbdev_vinfo;

int fbdev_init(void)
{
	fbdev_fn = getenv("FRAMEBUFFER");
	if (fbdev_fn == NULL)
		fbdev_fn = FBDEV_DEF;
	fbdev_fd = open(fbdev_fn, O_RDWR);
	if (fbdev_fd == -1) {
		fprintf(stderr,
			"can't open %s , reason: %s\n",
			fbdev_fn, strerror(errno));
		return -1;
	}
	if (ioctl(fbdev_fd, FBIOGET_FSCREENINFO, &fbdev_finfo) == -1) {
		fprintf(stderr,
			"can't get %s FSCREENINFO, reason: %s\n",
			fbdev_fn, strerror(errno));
		return -1;
	}
	if (ioctl(fbdev_fd, FBIOGET_VSCREENINFO, &fbdev_vinfo) == -1) {
		fprintf(stderr,
			"can't get %s VSCREENINFO, reason: %s\n",
			fbdev_fn, strerror(errno));
	}
	fbdev_mem = (uint8_t *) mmap(NULL, fbdev_finfo.smem_len,
				     PROT_READ | PROT_WRITE, MAP_SHARED,
				     fbdev_fd, 0);
	if ((void *)fbdev_mem == (void *)-1) {
		fprintf(stderr,
			"can't mmap %s, reason: %s\n",
			fbdev_fn, strerror(errno));
		return -1;
	}

	return 1;
}

#define fbdev_blank() memset(fbdev_mem, 0, fbdev_finfo.smem_len);

int fbdev_check_pos(unsigned int x, unsigned int y)
{
	if ((x > fbdev_vinfo.xres) || (y > fbdev_vinfo.yres))
		return -1;
	return 1;
}

void fbdev_draw_pixel(unsigned int x, unsigned int y, uint32_t color)
{
	if (fbdev_check_pos(x, y) == -1)
		return;
	int pos = y * fbdev_finfo.line_length +
	    x * sizeof(fbdev_vinfo.bits_per_pixel);
	uint8_t *fbp8 = (uint8_t *) fbdev_mem + pos;
	uint16_t *fbp16 = (uint16_t *) fbp8;
	uint32_t *fbp32 = (uint32_t *) fbp8;
	switch (fbdev_vinfo.bits_per_pixel) {
	case 32:
		*fbp32 = color;
		break;
	case 16:
		*fbp16 = color;
		break;
	case 8:
		*fbp8 = color;
		break;
	default:
		*fbp8 = color;
		break;
	}
	return;
}

void fbdev_draw_rect(unsigned int pos_x, unsigned int pos_y,
		     unsigned int rect_h, unsigned int rect_w, uint32_t color)
{
	unsigned int i;

	// up
	for (i = pos_x; i <= pos_x + rect_w; i++) {
		fbdev_draw_pixel(i, pos_y, color);
	}
	// down
	for (i = pos_x; i <= pos_x + rect_w; i++) {
		fbdev_draw_pixel(i, pos_y + rect_h, color);
	}
	// left
	for (i = pos_y; i <= pos_y + rect_h; i++) {
		fbdev_draw_pixel(pos_x, i, color);
	}
	// right
	for (i = pos_y; i <= pos_y + rect_h; i++) {
		fbdev_draw_pixel(pos_x + rect_w, i, color);
	}
	return;
}

void fbdev_draw_rect_solid(unsigned int pos_x, unsigned int pos_y,
			   unsigned int rect_h, unsigned int rect_w,
			   uint32_t color)
{
	unsigned int x, y;
	for (y = pos_y; y <= (pos_y + rect_h); y++) {
		for (x = pos_x; x <= (pos_x + rect_w); x++) {
			fbdev_draw_pixel(x, y, color);
		}
	}
	return;
}

// import from https://github.com/dhepper/font8x8/raw/master/font8x8_basic.h
char font_8x8[128][8] = {
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},	// U+0000 (nul)
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},	// U+0001
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},	// U+0002
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},	// U+0003
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},	// U+0004
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},	// U+0005
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},	// U+0006
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},	// U+0007
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},	// U+0008
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},	// U+0009
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},	// U+000A
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},	// U+000B
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},	// U+000C
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},	// U+000D
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},	// U+000E
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},	// U+000F
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},	// U+0010
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},	// U+0011
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},	// U+0012
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},	// U+0013
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},	// U+0014
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},	// U+0015
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},	// U+0016
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},	// U+0017
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},	// U+0018
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},	// U+0019
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},	// U+001A
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},	// U+001B
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},	// U+001C
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},	// U+001D
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},	// U+001E
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},	// U+001F
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},	// U+0020 (space)
	{0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00},	// U+0021 (!)
	{0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},	// U+0022 (")
	{0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00},	// U+0023 (#)
	{0x0C, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x0C, 0x00},	// U+0024 ($)
	{0x00, 0x63, 0x33, 0x18, 0x0C, 0x66, 0x63, 0x00},	// U+0025 (%)
	{0x1C, 0x36, 0x1C, 0x6E, 0x3B, 0x33, 0x6E, 0x00},	// U+0026 (&)
	{0x06, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00},	// U+0027 (')
	{0x18, 0x0C, 0x06, 0x06, 0x06, 0x0C, 0x18, 0x00},	// U+0028 (()
	{0x06, 0x0C, 0x18, 0x18, 0x18, 0x0C, 0x06, 0x00},	// U+0029 ())
	{0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00},	// U+002A (*)
	{0x00, 0x0C, 0x0C, 0x3F, 0x0C, 0x0C, 0x00, 0x00},	// U+002B (+)
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x06},	// U+002C (,)
	{0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00},	// U+002D (-)
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00},	// U+002E (.)
	{0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01, 0x00},	// U+002F (/)
	{0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00},	// U+0030 (0)
	{0x0C, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x3F, 0x00},	// U+0031 (1)
	{0x1E, 0x33, 0x30, 0x1C, 0x06, 0x33, 0x3F, 0x00},	// U+0032 (2)
	{0x1E, 0x33, 0x30, 0x1C, 0x30, 0x33, 0x1E, 0x00},	// U+0033 (3)
	{0x38, 0x3C, 0x36, 0x33, 0x7F, 0x30, 0x78, 0x00},	// U+0034 (4)
	{0x3F, 0x03, 0x1F, 0x30, 0x30, 0x33, 0x1E, 0x00},	// U+0035 (5)
	{0x1C, 0x06, 0x03, 0x1F, 0x33, 0x33, 0x1E, 0x00},	// U+0036 (6)
	{0x3F, 0x33, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x00},	// U+0037 (7)
	{0x1E, 0x33, 0x33, 0x1E, 0x33, 0x33, 0x1E, 0x00},	// U+0038 (8)
	{0x1E, 0x33, 0x33, 0x3E, 0x30, 0x18, 0x0E, 0x00},	// U+0039 (9)
	{0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x00},	// U+003A (:)
	{0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x06},	// U+003B (;)
	{0x18, 0x0C, 0x06, 0x03, 0x06, 0x0C, 0x18, 0x00},	// U+003C (<)
	{0x00, 0x00, 0x3F, 0x00, 0x00, 0x3F, 0x00, 0x00},	// U+003D (=)
	{0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00},	// U+003E (>)
	{0x1E, 0x33, 0x30, 0x18, 0x0C, 0x00, 0x0C, 0x00},	// U+003F (?)
	{0x3E, 0x63, 0x7B, 0x7B, 0x7B, 0x03, 0x1E, 0x00},	// U+0040 (@)
	{0x0C, 0x1E, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x00},	// U+0041 (A)
	{0x3F, 0x66, 0x66, 0x3E, 0x66, 0x66, 0x3F, 0x00},	// U+0042 (B)
	{0x3C, 0x66, 0x03, 0x03, 0x03, 0x66, 0x3C, 0x00},	// U+0043 (C)
	{0x1F, 0x36, 0x66, 0x66, 0x66, 0x36, 0x1F, 0x00},	// U+0044 (D)
	{0x7F, 0x46, 0x16, 0x1E, 0x16, 0x46, 0x7F, 0x00},	// U+0045 (E)
	{0x7F, 0x46, 0x16, 0x1E, 0x16, 0x06, 0x0F, 0x00},	// U+0046 (F)
	{0x3C, 0x66, 0x03, 0x03, 0x73, 0x66, 0x7C, 0x00},	// U+0047 (G)
	{0x33, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x00},	// U+0048 (H)
	{0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},	// U+0049 (I)
	{0x78, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E, 0x00},	// U+004A (J)
	{0x67, 0x66, 0x36, 0x1E, 0x36, 0x66, 0x67, 0x00},	// U+004B (K)
	{0x0F, 0x06, 0x06, 0x06, 0x46, 0x66, 0x7F, 0x00},	// U+004C (L)
	{0x63, 0x77, 0x7F, 0x7F, 0x6B, 0x63, 0x63, 0x00},	// U+004D (M)
	{0x63, 0x67, 0x6F, 0x7B, 0x73, 0x63, 0x63, 0x00},	// U+004E (N)
	{0x1C, 0x36, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x00},	// U+004F (O)
	{0x3F, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x0F, 0x00},	// U+0050 (P)
	{0x1E, 0x33, 0x33, 0x33, 0x3B, 0x1E, 0x38, 0x00},	// U+0051 (Q)
	{0x3F, 0x66, 0x66, 0x3E, 0x36, 0x66, 0x67, 0x00},	// U+0052 (R)
	{0x1E, 0x33, 0x07, 0x0E, 0x38, 0x33, 0x1E, 0x00},	// U+0053 (S)
	{0x3F, 0x2D, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},	// U+0054 (T)
	{0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x3F, 0x00},	// U+0055 (U)
	{0x33, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00},	// U+0056 (V)
	{0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00},	// U+0057 (W)
	{0x63, 0x63, 0x36, 0x1C, 0x1C, 0x36, 0x63, 0x00},	// U+0058 (X)
	{0x33, 0x33, 0x33, 0x1E, 0x0C, 0x0C, 0x1E, 0x00},	// U+0059 (Y)
	{0x7F, 0x63, 0x31, 0x18, 0x4C, 0x66, 0x7F, 0x00},	// U+005A (Z)
	{0x1E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x1E, 0x00},	// U+005B ([)
	{0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x40, 0x00},	// U+005C (\)
	{0x1E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E, 0x00},	// U+005D (])
	{0x08, 0x1C, 0x36, 0x63, 0x00, 0x00, 0x00, 0x00},	// U+005E (^)
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF},	// U+005F (_)
	{0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00},	// U+0060 (`)
	{0x00, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00},	// U+0061 (a)
	{0x07, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x3B, 0x00},	// U+0062 (b)
	{0x00, 0x00, 0x1E, 0x33, 0x03, 0x33, 0x1E, 0x00},	// U+0063 (c)
	{0x38, 0x30, 0x30, 0x3e, 0x33, 0x33, 0x6E, 0x00},	// U+0064 (d)
	{0x00, 0x00, 0x1E, 0x33, 0x3f, 0x03, 0x1E, 0x00},	// U+0065 (e)
	{0x1C, 0x36, 0x06, 0x0f, 0x06, 0x06, 0x0F, 0x00},	// U+0066 (f)
	{0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x1F},	// U+0067 (g)
	{0x07, 0x06, 0x36, 0x6E, 0x66, 0x66, 0x67, 0x00},	// U+0068 (h)
	{0x0C, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},	// U+0069 (i)
	{0x30, 0x00, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E},	// U+006A (j)
	{0x07, 0x06, 0x66, 0x36, 0x1E, 0x36, 0x67, 0x00},	// U+006B (k)
	{0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},	// U+006C (l)
	{0x00, 0x00, 0x33, 0x7F, 0x7F, 0x6B, 0x63, 0x00},	// U+006D (m)
	{0x00, 0x00, 0x1F, 0x33, 0x33, 0x33, 0x33, 0x00},	// U+006E (n)
	{0x00, 0x00, 0x1E, 0x33, 0x33, 0x33, 0x1E, 0x00},	// U+006F (o)
	{0x00, 0x00, 0x3B, 0x66, 0x66, 0x3E, 0x06, 0x0F},	// U+0070 (p)
	{0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x78},	// U+0071 (q)
	{0x00, 0x00, 0x3B, 0x6E, 0x66, 0x06, 0x0F, 0x00},	// U+0072 (r)
	{0x00, 0x00, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x00},	// U+0073 (s)
	{0x08, 0x0C, 0x3E, 0x0C, 0x0C, 0x2C, 0x18, 0x00},	// U+0074 (t)
	{0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x6E, 0x00},	// U+0075 (u)
	{0x00, 0x00, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00},	// U+0076 (v)
	{0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00},	// U+0077 (w)
	{0x00, 0x00, 0x63, 0x36, 0x1C, 0x36, 0x63, 0x00},	// U+0078 (x)
	{0x00, 0x00, 0x33, 0x33, 0x33, 0x3E, 0x30, 0x1F},	// U+0079 (y)
	{0x00, 0x00, 0x3F, 0x19, 0x0C, 0x26, 0x3F, 0x00},	// U+007A (z)
	{0x38, 0x0C, 0x0C, 0x07, 0x0C, 0x0C, 0x38, 0x00},	// U+007B ({)
	{0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00},	// U+007C (|)
	{0x07, 0x0C, 0x0C, 0x38, 0x0C, 0x0C, 0x07, 0x00},	// U+007D (})
	{0x6E, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},	// U+007E (~)
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}	// U+007F
};

void fbdev_draw_char(char c,
		     unsigned int pos_x, unsigned int pos_y,
		     uint32_t colorfg, uint32_t colorbg)
{
	if (!isprint(c))
		return;
	char *bitmap = font_8x8[c];
	unsigned int x, y;
	for (x = 0; x < 8; x++) {
		for (y = 0; y < 8; y++) {
			if (bitmap[y] & 1 << x) {
				fbdev_draw_pixel(pos_x + x, pos_y + y, colorfg);
			} else {
				fbdev_draw_pixel(pos_x + x, pos_y + y, colorbg);
			}
		}
	}
	return;
}

void fbdev_fill_random_pixel(useconds_t delay, unsigned long long count,
			     uint32_t * color)
{
	srand(time(NULL));
	unsigned int x;
	unsigned int y;
	uint32_t random_color;
	if (color == NULL)
		color = &random_color;
	while (count--) {
		random_color = rand();
		x = rand() % fbdev_vinfo.xres;
		y = rand() % fbdev_vinfo.yres;
		fbdev_draw_pixel(x, y, *color);
		usleep(delay);
	}
	return;
}

void fbdev_fill_random_rect(useconds_t delay, unsigned long long count,
			    uint32_t * color)
{
	unsigned int x;
	unsigned int y;
	unsigned int w;
	unsigned int h;
	srand(time(NULL));
	uint32_t random_color;
	if (color == NULL)
		color = &random_color;
	while (count--) {
		random_color = rand();
		x = rand() % fbdev_vinfo.xres;
		y = rand() % fbdev_vinfo.yres;
		w = rand() % (fbdev_vinfo.xres - x);
		h = rand() % (fbdev_vinfo.yres - y);
		fbdev_draw_rect(x, y, h, w, *color);
		usleep(delay);
	}
	return;
}

void fbdev_fill_random_rect_solid(useconds_t delay, unsigned long long count,
				  uint32_t * color)
{
	unsigned int x;
	unsigned int y;
	unsigned int w;
	unsigned int h;
	srand(time(NULL));
	uint32_t random_color;
	if (color == NULL)
		color = &random_color;
	while (count--) {
		random_color = rand();
		x = rand() % fbdev_vinfo.xres;
		y = rand() % fbdev_vinfo.yres;
		w = rand() % (fbdev_vinfo.xres - x);
		h = rand() % (fbdev_vinfo.yres - y);
		fbdev_draw_rect_solid(x, y, h, w, *color);
		usleep(delay);
	}
	return;
}

void fbdev_fill_random_char(useconds_t delay, unsigned long long count,
			    uint32_t * color)
{
	srand(time(NULL));
	unsigned int x;
	unsigned int y;
	uint32_t random_color;
	if (color == NULL)
		color = &random_color;
	unsigned char c;
	uint32_t colorbg = 0x0;	// black
	while (count--) {
		random_color = rand();
		c = rand() % 128;
		x = rand() % fbdev_vinfo.xres;
		y = rand() % fbdev_vinfo.yres;
		fbdev_draw_char(c, x, y, *color, colorbg);
		usleep(delay);
	}
	return;
}

void fbdev_uninit(void)
{
	if (fbdev_fd != -1)
		close(fbdev_fd);
	if ((void *)fbdev_mem != (void *)-1)
		munmap(fbdev_mem, fbdev_finfo.smem_len);
}

int main(int argc, char *argv[])
{
	if (argc < 4) {
		fprintf(stderr, "Usage: %s mode delay count [hex]\n", argv[0]);
		exit(EXIT_FAILURE);
	}
	if (fbdev_init() == -1)
		exit(EXIT_FAILURE);
	fbdev_blank();

	useconds_t delay = atoll(argv[2]);
	unsigned long long count = strtoull(argv[3], NULL, 10);
	uint32_t *colorp = NULL;
	uint32_t color;
	if (argc >= 5) {
		color = strtoll(argv[4], NULL, 16);
		colorp = &color;
	}

	if (strcmp(argv[1], "pixel") == 0) {
		fbdev_fill_random_pixel(delay, count, colorp);
	} else if (strcmp(argv[1], "rect") == 0) {
		fbdev_fill_random_rect(delay, count, colorp);
	} else if (strcmp(argv[1], "rect_solid") == 0) {
		fbdev_fill_random_rect_solid(delay, count, colorp);
	} else if (strcmp(argv[1], "char") == 0) {
		fbdev_fill_random_char(delay, count, colorp);
	}
	fbdev_uninit();
	return 0;
}
